pragma solidity ^0.5.12;
import "./Stamper.sol";
import "./CarboTag.sol";
/// @title Stamper Registry
/// @author Bertrand Williams-Rioux
/// @notice Use this to Generate new stamper contracts (offset credit generators).
/// @dev <docment-me>
contract StamperFactory{

  address public owner; // contract owner should be COG DAO
  uint public totalStamperCarbon; //metric for stamper carbon this can be non-negative
  uint public totalStamperGold; //metric for stamper gold
  uint public totalGold;   //metric for system gold

  modifier onlyGovernor () {    //added some governance
    require(governor[msg.sender] == true);
    _;
  }
  modifier onlyStamperContract(address _stamper) {  //added some security
    require(stamperRegistry[_stamper] == msg.sender, "Can only call from Stamper Contract");
    _;
  }

  /// @dev Contract constructor sets initial owner and required number of confirmations.
  /// @param _owners List of initial owners.
  /// @param _required Number of required confirmations.
  constructor(address _carboTagAddress) external {
    owner = msg.sender; // sender of the contract request is the owner, and should be a COG contract
    governor[msg.sender]=true;
    CarboTag carboTag = CarboTag(_carboTagAddress);
    totalGold = carboTag.totalGold();

    // reset stamper accounts in the new contract
    // stamperCount = oldContract.stamperCount;
    // totalStamperCarbon; //metric for stamper carbon this can be non-negative
    // totalStamperGold; //metric for stamper gold
  }
  function addStamper(address target, uint stamprate, uint minpmt) 
    public 
    // only contract governors can nominate stampers
    onlyGovernor()
    stamperDoesNotExsit(target)

  {
    Stamper stamper = new Stamper(target,msg.sender,stamprate,minpmt);

    stamperRegistry[target] = address(stamper);
    stamperIndex[stamperCount++]=target;
    //sumTokens();
    uint _carbon; //carbon to add to totalStamperCarbon
    if(wallet[target].carbon>0){
      _carbon = uint(wallet[target].carbon); // only pass positive carbon 
    }
    totalStamperCarbon += uint(_carbon);
    totalStamperGold += wallet[target].gold;
  }

  function updateGold(uint stamps, address stamper)
    public 
    onlyStamperContract(stamper)
  {
    // Some points to address
    // Block timestamp can be manipulated by miners within 900s
    // Make sure that this deos not distort the stamping rate within am acceptable tollerance
    // Need to set other stamp constriants (total stamps based on auditing, or other metrics)
    uint carbon;// new carbon generated by stamper if stamps exceed carbons)
    wallet[stamper].gold += stamps;
    if(wallet[stamper].carbon>int(stamps)){
      wallet[stamper].carbon -= int(stamps);
    }else{
      // Keeps stamper carbon from going negative
      // Stamper wallet can not have negative debt after stamping ...(?)
      wallet[stamper].carbon = 0;
      totalCarbon += stamps;
      // stamper creates new _carbon if it stamps more than it has carbon
      carbon = stamps - uint(wallet[stamper].carbon);
    } 

    totalGold += stamps;
    totalCarbon += carbon - stamps;
    totalStamperGold += stamps;
    totalStamperCarbon += carbon - stamps;
  }

  function updateStamperTotals(address _sender, address _receiver, int _carbon, int _gold) internal{
    //why do we need to update/store these???
    int8 _sign; // defines direction of carbon/gold movements
    bool _stamper=false;
    if(stamperRegistry[_sender]!= address(0x0)){
      _stamper = true;
      _sign = 1; // if stamper is sender values are sent out ( substract )
    }if(stamperRegistry[_receiver]!= address(0x0)){
      _stamper = !_stamper; //if both sender and receiver are stampers do nothing (no change in total gold/carbon balance)
      _sign = -1; // if stamper is receiver values are coming in (add)
    }
    // note when carbon/gold are negative these are asks by the sender and direction if flipped
    if(_stamper){
      totalStamperCarbon -= uint(_sign*_carbon);
      totalStamperGold -= uint(_sign*_gold);
    }
  }
}